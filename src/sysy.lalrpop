grammar;

use crate::ast::*;
use crate::token::{Token, LexicalError};

extern {
    type Location = usize;
    type Error = String;

    enum Token {
        IDENT => Token::Ident,
        INT_CONST => Token::IntConst,

        "const" => Token::Const,
        "if" => Token::If,
        "else" => Token::Else,
        "while" => Token::While,
        "break" => Token::Break,
        "continue" => Token::Continue,
        "return" => Token::Return,

        "+" => Token::Plus,
        "-" => Token::Minus,
        "!" => Token::Not,
        "*" => Token::Mul,
        "/" => Token::Div,
        "%" => Token::Mod,
        "^" => Token::Pow,

        "&" => Token::BitAnd,
        "~" => Token::BitNot,
        "|" => Token::BitOr,
        "<<" => Token::ShiftL,
        ">>" => Token::ShiftR,
        
        "&&" => Token::And,
        "||" => Token::Or,

        "<" => Token::Lt,
        ">" => Token::Gt,
        "<=" => Token::Le,
        ">=" => Token::Ge,
        "==" => Token::Eq,
        "!=" => Token::Neq,

        "=" => Token::Assign,
        
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        
        "," => Token::Comma,
        ";" => Token::SemiColon,
        ":" => Token::Colon,
        "::" => Token::DoubleColon,
        "." => Token::Dot,
        ".." => Token::Concat,
        "..." => Token::Dots,

        "int" => Token::Int,
        "void" => Token::Void,   
    }
}

CommaList<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub Stmt: Stmt = {
    AssignStatement => <>,
    ExpStatement => <>,
    // BlockStatement => <>,

    IfThenStatement => <>,
    IfThenElseStatement => <>,
    WhileStatement => <>,
    BreakStatement => <>,
    ContinueStatement => <>,
    ReturnStatement => <>,
};

AssignStatement: Stmt = <lval: LVal> "=" <exp: Exp> ";" => Stmt::Assign(lval, exp);

ExpStatement: Stmt = <exp: Exp?> ";" => Stmt::Exp(exp);

// BlockStatement: Stmt = <block: Block> => Stmt::Block(block);

BreakStatement: Stmt = "break" ";" => Stmt::Break;

ContinueStatement: Stmt = "continue" ";" => Stmt::Continue;
    
ReturnStatement: Stmt = "return" <exp: Exp?> ";" => Stmt::Return(exp);

IfThenStatement: Stmt = "if" "(" <cond: Exp> ")" <then: Stmt> => Stmt::If(cond, Box::new(then), None);

IfThenElseStatement: Stmt = "if" "(" <cond: Exp> ")" <then: StatementNoShortIf> "else" <else_: Stmt> => Stmt::If(cond, Box::new(then), Some(Box::new(else_)));

StatementNoShortIf: Stmt = {
    IfThenElseStatementNoShortIf => <>,
    WhileStatementNoShortIf => <>,
    // ForStatementNoShortIf => <>,
};

IfThenElseStatementNoShortIf: Stmt = "if" "(" <cond: Exp> ")" <then: StatementNoShortIf> "else" <else_: StatementNoShortIf> => Stmt::If(cond, Box::new(then), Some(Box::new(else_)));

WhileStatement: Stmt = "while" "(" <cond: Exp> ")" <body: Stmt> => Stmt::While(cond, Box::new(body));

WhileStatementNoShortIf: Stmt = "while" "(" <cond: Exp> ")" <body: StatementNoShortIf> => Stmt::While(cond, Box::new(body));

// Exp ::= LOrExp;
pub Exp: Exp = {
    <LOrExp> => Exp::LOrExp(Box::new(<>)),
};

// LVal ::= IDENT {"[" Exp "]"};
pub LVal: LVal = {
    <ident: IDENT> <indices: IndexList> => LVal {
        ident,
        indices,
    },
};

IndexList: Vec<Exp> = {
    => vec![],
    <mut indices: IndexList> "[" <exp: Exp> "]" => {
        indices.push(exp);
        indices
    },
};

// PrimaryExp ::= "(" Exp ")" | LVal | Number;
pub PrimaryExp: PrimaryExp = {
    "(" <exp: Exp> ")" => PrimaryExp::Paren(Box::new(exp)),
    <lval: LVal> => PrimaryExp::LVal(lval),
    <num: Number> => PrimaryExp::Number(num),
};

// Number ::= INT_CONST;
pub Number: i32 = {
    <num: INT_CONST> => num,
};

// UnaryExp ::= PrimaryExp | IDENT "(" [FuncRParams] ")" | UnaryOp UnaryExp;
pub UnaryExp: UnaryExp = {
    <op: UnaryOp> <exp: UnaryExp> => UnaryExp::UnaryOp(op, Box::new(exp)),
};

pub UnaryOp: UnaryOp = {
    "+" => UnaryOp::Add,
    "-" => UnaryOp::Sub,
    "!" => UnaryOp::Not,
};

// FuncRParams ::= Exp {"," Exp};
pub FuncRParams: FuncRParams = CommaList<Exp> => FuncRParams(<>);

// MulExp ::= UnaryExp | MulExp ("*" | "/" | "%") UnaryExp;
pub MulExp: MulExp = {
    <unary_exp: UnaryExp> => MulExp::UnaryExp(Box::new(unary_exp)),
    <mul_exp: MulExp> <factor_op: FactorOp> <unary_exp: UnaryExp> => {
        match factor_op {
            FactorOp::Mul => MulExp::Mul(Box::new(mul_exp), Box::new(unary_exp)),
            FactorOp::Div => MulExp::Div(Box::new(mul_exp), Box::new(unary_exp)),
            FactorOp::Mod => MulExp::Mod(Box::new(mul_exp), Box::new(unary_exp)),
        }
    },
};

// AddExp ::= MulExp | AddExp ("+" | "-") MulExp;
pub AddExp: AddExp = {
    <MulExp> => AddExp::MulExp(Box::new(<>)),
    <add_exp: AddExp> <binary_op: BinaryOp> <mul_exp: MulExp> => {
        match binary_op {
            BinaryOp::Add => AddExp::Add(Box::new(add_exp), Box::new(mul_exp)),
            BinaryOp::Sub => AddExp::Sub(Box::new(add_exp), Box::new(mul_exp)),
        }
    },
};

pub BinaryOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
};

pub FactorOp: FactorOp = {
    "*" => FactorOp::Mul,
    "/" => FactorOp::Div,
    "%" => FactorOp::Mod,
};

// RelExp ::= AddExp | RelExp ("<" | ">" | "<=" | ">=") AddExp;
pub RelExp: RelExp = {
    <add_exp: AddExp> => RelExp::AddExp(Box::new(add_exp)),
    <rel_exp: RelExp> <rel_op: RelOp> <add_exp: AddExp> => {
        match rel_op {
            RelOp::Lt => RelExp::Lt(Box::new(rel_exp), Box::new(add_exp)),
            RelOp::Gt => RelExp::Gt(Box::new(rel_exp), Box::new(add_exp)),
            RelOp::Le => RelExp::Le(Box::new(rel_exp), Box::new(add_exp)),
            RelOp::Ge => RelExp::Ge(Box::new(rel_exp), Box::new(add_exp)),
        }
    },
};

pub RelOp: RelOp = {
    "<" => RelOp::Lt,
    ">" => RelOp::Gt,
    "<=" => RelOp::Le,
    ">=" => RelOp::Ge,
};

// EqExp ::= RelExp | EqExp ("==" | "!=") RelExp;
pub EqExp: EqExp = {
    <RelExp> => EqExp::RelExp(Box::new(<>)),
    <eq_exp: EqExp> <eq_op: EqOp> <rel_exp: RelExp> => {
        match eq_op {
            EqOp::Eq => EqExp::Eq(Box::new(eq_exp), Box::new(rel_exp)),
            EqOp::Neq => EqExp::Neq(Box::new(eq_exp), Box::new(rel_exp)),
        }
    },
};

pub EqOp: EqOp = {
    "==" => EqOp::Eq,
    "!=" => EqOp::Neq,
};

// LAndExp ::= EqExp | LAndExp "&&" EqExp;
pub LAndExp: LAndExp = {
    <EqExp> => LAndExp::EqExp(Box::new(<>)),
    <land_exp: LAndExp> "&&" <eq_exp: EqExp> => LAndExp::And(Box::new(land_exp), Box::new(eq_exp)),
};

// LOrExp ::= LAndExp | LOrExp "||" LAndExp;
pub LOrExp: LOrExp = {
    <LAndExp> => LOrExp::LAndExp(Box::new(<>)),
    <lor_exp: LOrExp> "||" <land_exp: LAndExp> => LOrExp::Or(Box::new(lor_exp), Box::new(land_exp)),
};

// ConstExp ::= Exp;
pub ConstExp: ConstExp = <Exp> => ConstExp::Exp(Box::new(<>));