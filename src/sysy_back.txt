grammar;

use crate::ast::*;
use crate::token::{Token, LexicalError};

extern {
    type Location = usize;
    type Error = String;

    enum Token {
        IDENT => Token::Ident,
        INT_CONST => Token::IntConst,

        "const" => Token::Const,
        "if" => Token::If,
        "else" => Token::Else,
        "while" => Token::While,
        "break" => Token::Break,
        "continue" => Token::Continue,
        "return" => Token::Return,

        "+" => Token::Plus,
        "-" => Token::Minus,
        "!" => Token::Not,
        "*" => Token::Mul,
        "/" => Token::Div,
        "%" => Token::Mod,
        "^" => Token::Pow,

        "&" => Token::BitAnd,
        "~" => Token::BitNot,
        "|" => Token::BitOr,
        "<<" => Token::ShiftL,
        ">>" => Token::ShiftR,
        
        "&&" => Token::And,
        "||" => Token::Or,

        "<" => Token::Lt,
        ">" => Token::Gt,
        "<=" => Token::Le,
        ">=" => Token::Ge,
        "==" => Token::Eq,
        "!=" => Token::Neq,

        "=" => Token::Assign,
        
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        
        "," => Token::Comma,
        ";" => Token::SemiColon,
        ":" => Token::Colon,
        "::" => Token::DoubleColon,
        "." => Token::Dot,
        ".." => Token::Concat,
        "..." => Token::Dots,

        "int" => Token::Int,
        "void" => Token::Void,   
    }
}

// CompUnit ::= [CompUnit] (Decl | FuncDef);
pub CompUnit: CompUnit = {
    <prev_unit: CompUnit?> <cur_unit: DeclOrFuncDef> => {
        let prev_unit = match prev_unit {
            Some(prev_unit) => Some(Box::new(prev_unit)),
            None => None,
        };
        CompUnit {
            prev_unit,
            cur_unit,
        }
    },
};

DeclOrFuncDef: DeclOrFuncDef = {
    <decl: Decl> => DeclOrFuncDef::Decl(Box::new(decl)),
    <func_def: FuncDef> => DeclOrFuncDef::FuncDef(Box::new(func_def)),
};

// Decl ::= ConstDecl | VarDecl;
pub Decl: Decl = {
    <const_decl: ConstDecl> => Decl::ConstDecl(Box::new(const_decl)),
    <var_decl: VarDecl> => Decl::VarDecl(Box::new(var_decl)),
};

// ConstDecl ::= "const" BType ConstDef {"," ConstDef} ";";
pub ConstDecl: ConstDecl = {
    "const" <btype: BType> <const_defs: ConstDefList> ";" => ConstDecl {
        btype,
        const_defs,
    },
};

ConstDefList: Vec<ConstDef> = {
    <def: ConstDef> => vec![def],
    <mut defs: ConstDefList> "," <def: ConstDef> => {
        defs.push(def);
        defs
    },
};

// BType ::= "int";
pub BType: BType = {
    "int" => BType::Int,
};

// ConstDef ::= IDENT {"[" ConstExp "]"} "=" ConstInitVal;
pub ConstDef: ConstDef = {
    <ident: IDENT> <dimensions: DimensionList> "=" <init_val: ConstInitVal> => ConstDef {
        ident,
        dimensions,
        init_val,
    },
};

DimensionList: Vec<ConstExp> = {
    => vec![],
    <mut dims: DimensionList> "[" <exp: ConstExp> "]" => {
        dims.push(exp);
        dims
    },
};

// ConstInitVal ::= ConstExp | "{" [ConstInitVal {"," ConstInitVal}] "}";
pub ConstInitVal: ConstInitVal = {
    <exp: ConstExp> => ConstInitVal::Exp(Box::new(exp)),
    "{" <vals: ConstInitValList> "}" => ConstInitVal::Array(vals),
};

ConstInitValList: Vec<ConstInitVal> = {
    => vec![],
    <val: ConstInitVal> => vec![val],
    <mut vals: ConstInitValList> "," <val: ConstInitVal> => {
        vals.push(val);
        vals
    },
};

// VarDecl ::= BType VarDef {"," VarDef} ";";
pub VarDecl: VarDecl = {
    <btype: BType> <var_defs: VarDefList> ";" => VarDecl {
        btype,
        var_defs,
    },
};

VarDefList: Vec<VarDef> = {
    <def: VarDef> => vec![def],
    <mut defs: VarDefList> "," <def: VarDef> => {
        defs.push(def);
        defs
    },
};

// VarDef ::= IDENT {"[" ConstExp "]"} | IDENT {"[" ConstExp "]"} "=" InitVal;
pub VarDef: VarDef = {
    <ident: IDENT> <dimensions: DimensionList> => VarDef::Uninit(ident, dimensions),
    <ident: IDENT> <dimensions: DimensionList> "=" <init_val: InitVal> => VarDef::Init(ident, dimensions, init_val),
};

// InitVal ::= Exp | "{" [InitVal {"," InitVal}] "}";
pub InitVal: InitVal = {
    <exp: Exp> => InitVal::Exp(Box::new(exp)),
    "{" <vals: InitValList> "}" => InitVal::Array(vals),
};

InitValList: Vec<InitVal> = {
    => vec![],
    <val: InitVal> => vec![val],
    <mut vals: InitValList> "," <val: InitVal> => {
        vals.push(val);
        vals
    },
};

// FuncDef ::= FuncType IDENT "(" [FuncFParams] ")" Block;
pub FuncDef: FuncDef = {
    <func_type: FuncType> <ident: IDENT> "(" <params: FuncFParams> ")" <block: Block> => FuncDef {
        func_type,
        ident,
        params,
        block,
    },
};

// FuncType ::= "void" | "int";
pub FuncType: FuncType = {
    "void" => FuncType::Void,
    "int" => FuncType::Int,
};

// FuncFParams ::= FuncFParam {"," FuncFParam};
pub FuncFParams: Vec<FuncFParam> = {
    => vec![],
    <param: FuncFParam> => vec![param],
    <mut params: FuncFParams> "," <param: FuncFParam> => {
        params.push(param);
        params
    },
};

// FuncFParam ::= BType IDENT ["[" "]" {"[" ConstExp "]"}];
pub FuncFParam: FuncFParam = {
    <btype: BType> <ident: IDENT> => FuncFParam {
        btype,
        ident,
        is_array: false,
        dimensions: vec![],
    },
    <btype: BType> <ident: IDENT> "[" "]" <dimensions: DimensionList> => FuncFParam {
        btype,
        ident,
        is_array: true,
        dimensions,
    },
};

// Block ::= "{" {BlockItem} "}";
pub Block: Block = {
    "{" <items: BlockItem*> "}" => Block { items },
};

// BlockItem ::= Decl | Stmt;
pub BlockItem: BlockItem = {
    <decl: Decl> => BlockItem::Decl(Box::new(decl)),
    <stmt: Stmt> => BlockItem::Stmt(Box::new(stmt)),
};

// Stmt ::= LVal "=" Exp ";"
//        | [Exp] ";"
//        | Block
//        | "if" "(" Exp ")" Stmt ["else" Stmt]
//        | "while" "(" Exp ")" Stmt
//        | "break" ";"
//        | "continue" ";"
//        | "return" [Exp] ";";

pub Stmt: Stmt = {
    <lval: LVal> "=" <exp: Exp> ";" => Stmt::Assign(lval, exp),
    <exp: Exp?> ";" => Stmt::Exp(exp),
    <block: Block> => Stmt::Block(block),
    "if" "(" <cond: Exp> ")" <then: Stmt> "else" <else_: Stmt> => Stmt::If(cond, Box::new(then), Some(Box::new(else_))),
    "while" "(" <cond: Exp> ")" <body: Stmt> => Stmt::While(cond, Box::new(body)),
    "break" ";" => Stmt::Break,
    "continue" ";" => Stmt::Continue,
    "return" <exp: Exp?> ";" => Stmt::Return(exp),
};

// pub Stmt = StmtInner<"I">; // Allow dangling `if`
// 
// StmtInner<I>: Stmt = {
//     <lval: LVal> "=" <exp: Exp> ";" => Stmt::Assign(lval, exp),
//     <exp: Exp?> ";" => Stmt::Exp(exp),
//     <block: Block> => Stmt::Block(block),
//     "if" "(" <cond: Exp> ")" <then: StmtInner<"I">> if I != "" => Stmt::If(cond, Box::new(then), None),
//     "if" "(" <cond: Exp> ")" <then: StmtInner<"">> "else" <else_: StmtInner<I>> => Stmt::If(cond, Box::new(then), Some(Box::new(else_))),
//     "while" "(" <cond: Exp> ")" <body: Stmt> => Stmt::While(cond, Box::new(body)),
//     "break" ";" => Stmt::Break,
//     "continue" ";" => Stmt::Continue,
//     "return" <exp: Exp?> ";" => Stmt::Return(exp),
// }








// Exp ::= LOrExp;
pub Exp: Exp = {
    <lor_exp: LOrExp> => Exp::LOrExp(Box::new(lor_exp)),
};

// LOrExp ::= LAndExp | LOrExp "||" LAndExp;
pub LOrExp: LOrExp = {
    <land_exp: LAndExp> => LOrExp::LAndExp(Box::new(land_exp)),
    <lor_exp: LOrExp> "||" <land_exp: LAndExp> => LOrExp::Or(Box::new(lor_exp), Box::new(land_exp)),
};

// LAndExp ::= EqExp | LAndExp "&&" EqExp;
pub LAndExp: LAndExp = {
    <eq_exp: EqExp> => LAndExp::EqExp(Box::new(eq_exp)),
    <land_exp: LAndExp> "&&" <eq_exp: EqExp> => LAndExp::And(Box::new(land_exp), Box::new(eq_exp)),
};

// EqExp ::= RelExp | EqExp ("==" | "!=") RelExp;
pub EqExp: EqExp = {
    <rel_exp: RelExp> => EqExp::RelExp(Box::new(rel_exp)),
    <eq_exp: EqExp> "==" <rel_exp: RelExp> => EqExp::Eq(Box::new(eq_exp), RelOp::Eq, Box::new(rel_exp)),
    <eq_exp: EqExp> "!=" <rel_exp: RelExp> => EqExp::Neq(Box::new(eq_exp), RelOp::Neq, Box::new(rel_exp)),
};

// RelExp ::= AddExp | RelExp ("<" | ">" | "<=" | ">=") AddExp;
pub RelExp: RelExp = {
    <add_exp: AddExp> => RelExp::AddExp(Box::new(add_exp)),
    <rel_exp: RelExp> "<" <add_exp: AddExp> => RelExp::Lt(Box::new(rel_exp), Box::new(add_exp)),
    <rel_exp: RelExp> ">" <add_exp: AddExp> => RelExp::Gt(Box::new(rel_exp), Box::new(add_exp)),
    <rel_exp: RelExp> "<=" <add_exp: AddExp> => RelExp::Le(Box::new(rel_exp), Box::new(add_exp)),
    <rel_exp: RelExp> ">=" <add_exp: AddExp> => RelExp::Ge(Box::new(rel_exp), Box::new(add_exp)),
};

// AddExp ::= MulExp | AddExp ("+" | "-") MulExp;
pub AddExp: AddExp = {
    <mul_exp: MulExp> => AddExp::MulExp(Box::new(mul_exp)),
    <add_exp: AddExp> "+" <mul_exp: MulExp> => AddExp::Add(Box::new(add_exp), Box::new(mul_exp)),
    <add_exp: AddExp> "-" <mul_exp: MulExp> => AddExp::Sub(Box::new(add_exp), Box::new(mul_exp)),
};

// MulExp ::= UnaryExp | MulExp ("*" | "/" | "%") UnaryExp;
pub MulExp: MulExp = {
    <unary_exp: UnaryExp> => MulExp::UnaryExp(Box::new(unary_exp)),
    <mul_exp: MulExp> "*" <unary_exp: UnaryExp> => MulExp::Mul(Box::new(mul_exp), Box::new(unary_exp)),
    <mul_exp: MulExp> "/" <unary_exp: UnaryExp> => MulExp::Div(Box::new(mul_exp), Box::new(unary_exp)),
    <mul_exp: MulExp> "%" <unary_exp: UnaryExp> => MulExp::Mod(Box::new(mul_exp), Box::new(unary_exp)),
};

// UnaryExp ::= PrimaryExp | IDENT "(" [FuncRParams] ")" | UnaryOp UnaryExp;
pub UnaryExp: UnaryExp = {
    <primary_exp: PrimaryExp> => UnaryExp::PrimaryExp(Box::new(primary_exp)),
    <ident: IDENT> "(" <params: FuncRParams> ")" => UnaryExp::Call(ident, params),
    <op: UnaryOp> <unary_exp: UnaryExp> => UnaryExp::UnaryOp(op, Box::new(unary_exp)),
};

// PrimaryExp ::= "(" Exp ")" | LVal | Number;
pub PrimaryExp: PrimaryExp = {
    "(" <exp: Exp> ")" => PrimaryExp::Paren(Box::new(exp)),
    <lval: LVal> => PrimaryExp::LVal(lval),
    <num: Number> => PrimaryExp::Number(num),
};

// Number ::= INT_CONST;
pub Number: i32 = {
    <num: INT_CONST> => num,
};

// LVal ::= IDENT {"[" Exp "]"};
pub LVal: LVal = {
    <ident: IDENT> <indices: IndexList> => LVal {
        ident,
        indices,
    },
};

IndexList: Vec<Exp> = {
    => vec![],
    <mut indices: IndexList> "[" <exp: Exp> "]" => {
        indices.push(exp);
        indices
    },
};

// FuncRParams ::= Exp {"," Exp};
pub FuncRParams: Vec<Exp> = {
    => vec![],
    <param: Exp> => vec![param],
    <mut params: FuncRParams> "," <param: Exp> => {
        params.push(param);
        params
    },
};

// UnaryOp ::= "+" | "-" | "!";
pub UnaryOp: UnaryOp = {
    "+" => UnaryOp::Plus,
    "-" => UnaryOp::Minus,
    "!" => UnaryOp::Not,
};

// ConstExp ::= Exp;
pub ConstExp: ConstExp = {
    <exp: Exp> => ConstExp::Exp(Box::new(exp)),
};